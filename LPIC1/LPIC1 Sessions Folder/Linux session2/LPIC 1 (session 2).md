---
tags:
  - "#linux"
  - LPIC
  - command
  - concept
up: "[[LPIC1 Sessions map of content]]"
date: 2023-10-11
---
### bash
> [!idea] [kernel]  
> هسته لینوکس یا میانی ترین بخش سیستم کرنل است.
> کرنل بخشی است که با سخت افزار سیستم مستقیما در ارتباط است و اون رو مدیریت می‌کند.

> [!idea] shell
> ابزاری است که ما از طریق اون با کرنل لینوکس ارتباط برقرار میکنیم
> دو مدل شل گرافیکی و متنی وجود داره که تمامی سیستم ادمین‌ها از مدل متنی استفاده می‌کنند.
> - CLI shell   &   GUI shell
> شلهای مختلفی مانند bash , ZSH وجود دارد
> از محبوب ترین هاش bash هست و ما به عنوان سیستم ادمین با بش کار میکنیم.

> [!hint] متنی یا گرافیکی؟
> **یک سیستم ادمین حتما باید با محیط متنی کار کند.**
> - محیط گرافیکی در لینوکس خودش یک نرم افزار مجزا است و برخلاف ویندوز محیطهای گرافیکی بیشماری در لینوکس وجود دارد اما محیط متنی یکسان است.
> - اتوماسیون فقط از طریق محیط متنی اتفاق می‌افتد.

> [!idea] [[bash]]
> #command   نرم افزار بش رابط کاربری ما با هسته سیستم است.

ما به ندرت وارد یوزر روت می‌شویم چرا که یوزر خطرناکی است و دستورات در یوزر روت قطعا اجرا می‌شوند. 
اما میتوانیم در هر لحظه دسترسی روت بگیریم.
> [!code] [[su]] 
> #command  دستور سویچ یوزر  

### Sudo
> [!code] [[sudo]]
> در مکانیزم سودو یک یوزر غیر روت با پسورد خودش دسترسی روت میگیرد.
> هر یوزری این قابلیت رو ندارند و به یوزرهایی که این قابلیت رو دارند سودئر می‌گوییم.
> با سودو میتونیم دستورات رو با دسترسی روت اجرا کنیم.
> #command 

> [!code] [whoami]  به ما نشان میدهد با چه یوزری در حال کار هستیم

> [!code] [exit] برای خروج از هر محیطی ازین دستور استفاده می‌شود مثلا بعد از su با دستور exit میتوانیم به شل یوزر قبلی برگردیم.

> [!question]  تفاوت su و sudo چیست؟
> اگر بخواهیم با دستور su وارد یوزر root شویم و کاری انجام دهیم باید پسورد یوزر root رو داشته باشیم. اما با دستور sudo میتوانیم با پسورد یوزر، اما با دسترسی root دستورات رو اجرا کنیم.

> [!idea] 
> به نفع ماست که کمتر از سوپریوزر یا همان یوزر root استفاده کنیم. 
#### خط فرمان
خط فرمان در اکثر لینوکس‌ها یک شکل است اما با توجه به اینکه یک متغیر محیطی در لینوکس است، میتوان آن را به دلخواه تغییر داد.
خط فرمان شامل:
نام یوزر **@** نام کامپیوتر **:** مسیر جاری **$** یا **#**
```bash
user_name  @ computer_name  : path  $/# command line
```
در مثال بالا :
علامت ~ به معنای مسیر Home است.
علامت $ به معنای یوزر معمولی است.
علامت # به معنای سوپر یوزر است.
برای اجرای دستورات باید بعد از نوشتن دستور دکمه اینتر را بزنیم. و در مقابل هر دستوری میتوانیم آرگومان‌های لازم را بنویسم.
> [!idea] کارکترهای اختصاصی بش [[bash special character]]
> white space = جدا کننده طبیعی
> $(var) = داخل یک متغیر را نشان میدهد
> ~ = میانبری برای آدرس دایرکتوری home است.
#### دستورات
هر دستوری که اجرا می‌شود شامل دو بخش دستور و آرگومان می‌تواند باشد.
```bash
user@computer:~$ ls /bin
```
در مثال بالا ls دستور است و ls و /bin هر دو آرگومان هستند.
خود دستور هم به عنوان آرگومان به فایل اجرایی ارسال می‌شود.
دستورات به دو دسته [[internal command]] و **external command** تقسیم می‌شوند.
هر دستور اکسترنالی یک فایل اجرایی دارد. که bash آنها را در بخش‌های مختلفی جستجو می‌کند.
لیست جاهایی که جستجو می‌شوند در متغیر محیطی به نام PATH ذخیره می‌شود. 
```bash
mehdi@mvm:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```
برای پیدا کردن محل ذخیره سازی هر فایل مربوط به دستورات می‌توان از دستور Which یا type استفاده کرد.
```bash
mehdi@mvm:~$ which false
/usr/bin/false
mehdi@mvm:~$ which ls
/usr/bin/ls
hdi@mvm:~$ type which
which is /usr/bin/which
mehdi@mvm:~$ type wait
wait is a shell builtin
```

> [!idea] هر دستوری به شرط external بودنش یک فایل قابل اجراست. 
> در واقع ما چیزی به اسم دستور نداریم. هر دستوری در لینوکس یک برنامه با یک فایل اجرایی است.
> مثلا وقتی ping 9.9.9.9 را اجرا میکنیم در واقع برنامه پینگ با آرگومان چهار 9 را اجرا میکنیم.
#### تکست ادیتور VIM و nano
ویم یک تکت ادیتور حرفه ای و نانو یک تکست ادیتور ساده در لینوکس هستند.
#### کامپایلر C
ابزاری که در لینوکس برای کامپایل فایل‌های c استفاده میکنیم ابزار gcc است. در صورتی که این ابزار را نداشته باشیم با دستور زیر آن را نصب میکنیم:
sudo apt install gcc
> [!idea] دایرکتوری جاری CWD
> زمانی که ما در bash هستیم قطعا در یک دایرکتوری مشخص هستیم. به دایرکتوری که در آن فعال هستیم دایرکتوری جاری یا current working directory می‌گوییم.

> [!code] [[pwd]]   #command
> این دستور به ما نشان میدهد که دایرکتوری جاری چیست
> print working directory 

> [!idea] لینوکس دایرکتوری جاری را برای پیدا کردن یک فایل اجرایی جستجو نمی کند بلکه یک سری دایرکتوری‌های خاص برای فایل‌های اجرایی دارد و فقط همان‌ها رو جستجو می‌کند. 
> 

#### متغیرهای محیطی یا environment variable 
این متغیر‌ها ربطی به سیستم عامل لینوکس ندارند و متغیرهایی هستند که در شل وجود دارند.
> [!code] [[echo]] #command
> دستور echo آرگومان‌هایی که بهش ارسال میشود را به خروجی ارسال می‌کند. یعنی میتواند به صفحه نمایش یا یک فایل ارسال کند.

> [!question] در دستور زیر چه آرگومانی به اکو پاس داده می‌شود؟
> echo $PATH
> جواب: مقداری که در متغیر پت ذخیره شده است به اکو پاس داده میشود.

> [!code] [[printenv]]  
> این دستور لیستی از متغیرهای محیطی که در دسترس تمام نرم افزارهاست را نمایش میدهد.
> #command

برای تعریف متغیر کافیست اسم متغیر و = و مقدار متغیر را (بدون space)بنویسیم. اما این متغیر با دستور printenv دیده نمی‌شود. چرا که این متغیرها متغیرهای محیطی shell هستند و در دسترس نرم افزارهای دیگر (دستورات اکسترنال) نیستیند.

> [!question] چطور میتوانیم متغیرهای محیطی را در اختیار برنامه‌های غیر از shell قرار دهیم؟
> با دستور export

> [!code] [[export]] #command
> دستور اکسپورت برای در دسترس قرار دادن متغیرهای محیطی shell برای دیگر برنامه هاست. مثال:
> export c=12

یکی از کاربردهای متغیرهای محیطی استفاده برنامه نویسان ازین متغیرهاست. درواقع با استفاده از این متغیرهاست که یک برنامه میتواند با بیرون از خودش ارتباط بگیرد.
**اما متغیرهای محیطی با خروج از bash از بین می‌روند** و با شروع مجدد bash این متغیرها مجددا تعریف می‌شوند. این متغییرها به ازای هر کاربر متفاوت است و در هوم فولدر هر شخصی در فایل .bashrc قرار دارد. که با دستور زیر به آن دسترسی خواهیم داشت. و با تعریف متغیر در این فایل متغیر ما با راه اندازی مجدد bash بازتعریف شود. 
```bash
vi .bashrc
export C=12
```

> [!code] [[ps]] #command
> این دستور به ما نشان می‌دهد چه پروسس‌هایی در حال اجراست

#### دایرکتوری /
وقتی لینوکس را روی یک پارتیشن نصب میکنیم، محتویات آن روی فولدر / دیده می‌شوند، mount شدن یا سوار شدن یک پارتیشن روی یک فولدر باعث می‌شود که از طریق آن فولدر به محتویات آن پارتیشن دسترسی پیدا کنیم.

> [!idea] جدا کننده / 
> در لینوکس جدا کننده آدرس‌ها / هستند. برای مثال در آدرس زیر
> /home/peyman
> اولین اسلش دایرکتوری لینوکس ماست و اسلش‌های بعدی جداکننده آدرس هستند. 

> [!code] [[cd]]  #command
> این دستور یک دستور داخلی بش است که دایرکتوری جاری را تغییر میدهد.

> [!question] کدام گزینه ما را به دایرکتوری home نمی برد؟
> 1. cd
> 2. cd $HOME
> 3. cd ~
> 4. cd $MYHOME
> جواب گزینه 4 

#### مسیردادن
برخی دستورات در لینوکس مسیرهایی را به عنوان آرگومان دریافت میکنند.
**مسیر دادن همیشه باید با / شروع شود./ اول به معنای دایرکتوری root ماست و  اما /‌های بعدی صرفا جدا کننده هستند. اما اگر مسیردهی را با / شروع نکنیم bash خطای نمی دهد اما جور دیگری آن را میفهمد**
1. مسیری که با / شروع می‌شود یا مسیر دهی مطلق (absolute)
2. مسیری که با / شروع نمی‌شود یا مسیر دهی نسبی (Relative)
##### مسیر دهی نسبی
در مسیر دهی نسبی bash آدرس مورد نظر را نسبت به دایرکتوری جاری بررسی می‌کند.

ما باید سعی کنیم کمتر دایرکتوری جاری را تغییر دهیم و از همان دایرکتوری Home مسیر دهیم.

##### آدرس‌های . و ..
در لینوکس در تمامی فولدرها دو فولدر مجازی . و .. وجود دارد که مخفی هستند.
. یک آدرس نسبی است که اشاره به فولدر جاری می‌کند.
.. یک آدرس نسبی است که اشاره به فولدر پرنت یا قبلی می‌کند.
مواردی از استفاده از این دو فولدر مجازی:
1. برای اجرای یک فایل باید اسم به همراه آدرس آن تایپ شود بنابراین می‌توانیم در صورتی که آن فایل در فولدر جاری است به جای تایپ کامل آدرس از file name/. استفاده کنیم.
2. برای تغییر فولدر جاری به فولدر قبلی با دستور cd
3. برای کپی یک فایل به فولدر جاری یا از فولدر جاری با دستور cp
```bash
./exe_file
cd exe file
cd ..
cp /home/peyman/test.text .
```

> [!code] [[cat]]  
> محتویات یک فایل را به خروجی استاندارد می‌دهد.
> #command

> [!code] [[man]]  
> جزئیات و مشتقات هر دستور را به ما نشان میدهد.
> برای خرج از منوال یک دستور باید از کلید q استفاده کنیم.
> برای جتستجو در man یک دستور باید از / و Enter استفاده کنیم.
> #command

### خروجی استاندارد STDOUT
![[Pasted image 20231003185716.png]]

- فرایند اجرای برنامه‌ها و دستورات به این صورت است:
- بش ورودی‌های خود را به عنوان ورودی استاندارد به کرنل برای پرادزش ارسال می‌کند و خروجی‌های پردازشِ کرنل را به عنوان خروجی استاندارد دریافت می‌کند.
- کاربر با بش در ارتباط است و ورودی پیش فرض بش کیبرد و با کلیدهای ctrl+d ورودی گرفتن را متوقف می‌کند و خروجی آن اسکرین است.
- اما میتوان از بش درخواست کرد که ورودی و خروجی را ریدایرکت کند به این صورت که  ورودی را از فایل خوانش کند و خروجی را در فایل ذخیره کند
- سومین روش این است که از بش درخواست کنیم خروجی استاندارد را دوباره به عنوان ورودی پردازش دیگری به ورودی استاندارد ارسال کند و لزوما آن را در اسکرین نمایش ندهد و یا در فایل ذخیره نکند.
مثال:
```bash
date > output.txt
cat < output.txt
ls > output
grep m < output
```
مثال ریدایرکت:
```bash
ls | grep p 
# output
# snap
# Templates
ls | sort -r | grep m
# Templates
# snap
# output
```
